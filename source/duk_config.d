module duk_config;
/*
 *  duk_config.h configuration header generated by genconfig.py.
 *
 *  Git commit: d7fdb67f18561a50e06bafd196c6b423af9ad6fe
 *  Git describe: v2.3.0
 *  Git branch: master
 *
 *  Supported platforms:
 *      - Mac OSX, iPhone, Darwin
 *      - Orbis
 *      - OpenBSD
 *      - Generic BSD
 *      - Atari ST TOS
 *      - AmigaOS
 *      - Durango (XboxOne)
 *      - Windows
 *      - Flashplayer (Crossbridge)
 *      - QNX
 *      - TI-Nspire
 *      - Emscripten
 *      - Linux
 *      - Solaris
 *      - AIX
 *      - HPUX
 *      - Generic POSIX
 *      - Cygwin
 *      - Generic UNIX
 *      - Generic fallback
 *
 *  Supported architectures:
 *      - x86
 *      - x64
 *      - x32
 *      - ARM 32-bit
 *      - ARM 64-bit
 *      - MIPS 32-bit
 *      - MIPS 64-bit
 *      - PowerPC 32-bit
 *      - PowerPC 64-bit
 *      - SPARC 32-bit
 *      - SPARC 64-bit
 *      - SuperH
 *      - Motorola 68k
 *      - Emscripten
 *      - Generic
 *
 *  Supported compilers:
 *      - Clang
 *      - GCC
 *      - MSVC
 *      - Emscripten
 *      - TinyC
 *      - VBCC
 *      - Bruce's C compiler
 *      - Generic
 *
 */

import core.stdc.config;

import core.stdc.math;
import core.stdc.stdint;
import core.stdc.stdio;
import core.stdc.stdlib;
import core.stdc.string;
import core.sys.posix.setjmp;
import core.stdc.limits;
public import core.stdc.stdarg;

extern (C):

/*
 *  Intermediate helper defines
 */

/* DLL build detection */
/* not configured for DLL build */

/* Apple OSX, iOS */

/* FreeBSD */

/* Orbis (PS4) variant */

/* OpenBSD */

/* NetBSD */

/* BSD variant */

/* Atari ST TOS.  __TOS__ defined by PureC.  No platform define in VBCC
 * apparently, so to use with VBCC user must define __TOS__ manually.
  */

/* Motorola 68K.  Not defined by VBCC, so user must define one of these
 * manually when using VBCC.
 */

/* AmigaOS.  Neither AMIGA nor __amigaos__ is defined on VBCC, so user must
 * define 'AMIGA' manually when using VBCC.
 */

/* PowerPC */

/* Durango (Xbox One) */

/* Windows, both 32-bit and 64-bit */

/* Flash player (e.g. Crossbridge) */

/* QNX */

/* TI-Nspire (using Ndless) */

/* Emscripten (provided explicitly by user), improve if possible */

/* BCC (Bruce's C compiler): this is a "torture target" for compilation */

/* Linux */

/* illumos / Solaris */

/* Defines _ILP32 / _LP64 required by DUK_F_X86/DUK_F_X64.  Platforms
 * are processed before architectures, so this happens before the
 * DUK_F_X86/DUK_F_X64 detection is emitted.
 */

/* AIX */

/* defined(__xlc__) || defined(__IBMC__): works but too wide */

/* HPUX */

/* POSIX */

/* Cygwin */

/* Generic Unix (includes Cygwin) */

/* Intel x86 (32-bit), x64 (64-bit) or x32 (64-bit but 32-bit pointers),
 * define only one of DUK_F_X86, DUK_F_X64, DUK_F_X32.
 * https://sites.google.com/site/x32abi/
 *
 * With DUK_F_OLD_SOLARIS the <sys/isa_defs.h> header must be included
 * before this.
 */

/* This should not really happen, but would indicate x64. */

/* ARM */

/* MIPS.  Related defines: __MIPSEB__, __MIPSEL__, __mips_isa_rev, __LP64__ */

/* SPARC */

/* SuperH */

/* Clang */

/* C++ */

/* C99 or above */

/* C++11 or above */

/* GCC.  Clang also defines __GNUC__ so don't detect GCC if using Clang. */

/* Convenience, e.g. gcc 4.5.1 == 40501; http://stackoverflow.com/questions/6031819/emulating-gccs-builtin-unreachable */

/* MinGW.  Also GCC flags (DUK_F_GCC) are enabled now. */

/* MSVC */

/* MSVC preprocessor defines: http://msdn.microsoft.com/en-us/library/b0084kay.aspx
 * _MSC_FULL_VER includes the build number, but it has at least two formats, see e.g.
 * BOOST_MSVC_FULL_VER in http://www.boost.org/doc/libs/1_52_0/boost/config/compiler/visualc.hpp
 */

/* _MSC_VER */

/* TinyC */

/* http://bellard.org/tcc/tcc-doc.html#SEC9 */

/* VBCC */

/* Atari Mint */

/*
 *  Platform autodetection
 */

/* Workaround for older C++ compilers before including <inttypes.h>,
 * see e.g.: https://sourceware.org/bugzilla/show_bug.cgi?id=15366
 */

/* --- Mac OSX, iPhone, Darwin --- */

/* http://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor */

/* Use _setjmp() on Apple by default, see GH-55. */

/* --- Orbis --- */
/* Orbis = PS4 */

/* no parsing (not an error) */

/* --- OpenBSD --- */
/* http://www.monkey.org/openbsd/archive/ports/0401/msg00089.html */

/* --- Generic BSD --- */

/* --- Atari ST TOS --- */

/* no parsing (not an error) */

/* TOS on M68K is always big endian. */

/* --- AmigaOS --- */

/* AmigaOS on M68k */

/* no parsing (not an error) */

/* AmigaOS on M68K or PPC is always big endian. */

/* --- Durango (XboxOne) --- */
/* Durango = XboxOne
 * Configuration is nearly identical to Windows, except for
 * DUK_USE_DATE_TZO_WINDOWS.
 */

/* Initial fix: disable secure CRT related warnings when compiling Duktape
 * itself (must be defined before including Windows headers).  Don't define
 * for user code including duktape.h.
 */

/* MSVC does not have sys/param.h */

/* Note: PRS and FMT are intentionally left undefined for now.  This means
 * there is no platform specific date parsing/formatting but there is still
 * the ISO 8601 standard format.
 */

/* Only include when compiling Duktape to avoid polluting application build
 * with a lot of unnecessary defines.
 */

/* --- Windows --- */
/* Windows version can't obviously be determined at compile time,
 * but _WIN32_WINNT indicates the minimum version targeted:
 * - https://msdn.microsoft.com/en-us/library/6sehtctf.aspx
 */

/* Initial fix: disable secure CRT related warnings when compiling Duktape
 * itself (must be defined before including Windows headers).  Don't define
 * for user code including duktape.h.
 */

/* Windows 32-bit and 64-bit are currently the same. */
/* MSVC does not have sys/param.h */

/* Only include when compiling Duktape to avoid polluting application build
 * with a lot of unnecessary defines.
 */

/* GetSystemTimePreciseAsFileTime() available from Windows 8:
 * https://msdn.microsoft.com/en-us/library/windows/desktop/hh706895(v=vs.85).aspx
 */

/* User forced provider. */

/* Note: PRS and FMT are intentionally left undefined for now.  This means
 * there is no platform specific date parsing/formatting but there is still
 * the ISO 8601 standard format.
 */

/* QueryPerformanceCounter() may go backwards in Windows XP, so enable for
 * Vista and later: https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx#qpc_support_in_windows_versions
 */

/* On Windows, assume we're little endian.  Even Itanium which has a
 * configurable endianness runs little endian in Windows.
 */

/* --- Flashplayer (Crossbridge) --- */

/* --- QNX --- */

/* See: /opt/qnx650/target/qnx6/usr/include/sys/platform.h */

/* --- TI-Nspire --- */

/* e.g. strptime */

/* --- Emscripten --- */

/* e.g. getdate_r */

/* e.g. strptime */

/* DUK_COMPILING_DUKTAPE */

/* no endian.h */

/* DUK_F_BCC */

/* --- Linux --- */

/* e.g. getdate_r */

/* e.g. strptime */

/* DUK_COMPILING_DUKTAPE */

/* no endian.h or stdint.h */

/* DUK_F_BCC */

/* XXX: safe condition? */

enum DUK_USE_OS_STRING = "linux";

/* --- Solaris --- */

/* Old Solaris with no endian.h, stdint.h */

/* DUK_F_OLD_SOLARIS */

/* DUK_F_OLD_SOLARIS */

/* --- AIX --- */

/* --- HPUX --- */

/* --- Generic POSIX --- */

/* --- Cygwin --- */
/* don't use strptime() for now */

/* --- Generic UNIX --- */

/* --- Generic fallback --- */
/* The most portable current time provider is time(), but it only has a
 * one second resolution.
 */

/* The most portable way to figure out local time offset is gmtime(),
 * but it's not thread safe so use with caution.
 */

/* Avoid custom date parsing and formatting for portability. */

/* Rely on C89 headers only; time.h must be here. */

/* autodetect platform */

/* Shared includes: C89 */

/* varargs */

/* e.g. ptrdiff_t */

/* date.h is omitted, and included per platform */

/* Shared includes: stdint.h is C99 */

/* stdint.h not available */

/* Technically C99 (C++11) but found in many systems.  On some systems
 * __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS must be defined before
 * including stdint.h (see above).
 */

/* <exception> is only included if needed, based on DUK_USE_xxx flags. */

/*
 *  Architecture autodetection
 */

/* --- x86 --- */

/* FreeBSD, -m32, and clang prior to 5.0 has union aliasing issues which
 * break duk_tval copying.  Disable packed duk_tval automatically.
 */

/* --- x64 --- */

/* --- x32 --- */

/* --- ARM 32-bit --- */

/* Byte order varies, so rely on autodetect. */

/* --- ARM 64-bit --- */

/* Byte order varies, so rely on autodetect. */

/* --- MIPS 32-bit --- */

/* MIPS byte order varies so rely on autodetection. */

/* --- MIPS 64-bit --- */

/* MIPS byte order varies so rely on autodetection. */

/* --- PowerPC 32-bit --- */

/* --- PowerPC 64-bit --- */

/* --- SPARC 32-bit --- */

/* SPARC byte order varies so rely on autodetection. */

/* --- SPARC 64-bit --- */

/* SPARC byte order varies so rely on autodetection. */

/* --- SuperH --- */

/* Byte order varies, rely on autodetection. */

/* --- Motorola 68k --- */

/* --- Emscripten --- */

/* --- Generic --- */
/* These are necessary wild guesses. */

/* Rely on autodetection for byte order, alignment, and packed tval. */
/* autodetect architecture */

/*
 *  Compiler autodetection
 */

/* --- Clang --- */

/* C99 / C++11 and above: rely on va_copy() which is required. */

/* Clang: assume we have __va_copy() in non-C99 mode. */

/* DUK_HOT */
/* DUK_COLD */

/* MSVC dllexport/dllimport: appropriate __declspec depends on whether we're
 * compiling Duktape or the application.
 */

/*empty*/

/* Minimize warnings for unused internal functions with GCC >= 3.1.1 and
 * Clang.  Based on documentation it should suffice to have the attribute
 * in the declaration only, but in practice some warnings are generated unless
 * the attribute is also applied to the definition.
 */

/* --- GCC --- */

/* C99 / C++11 and above: rely on va_copy() which is required. */

/* GCC: assume we have __va_copy() in non-C99 mode. */

/* since gcc-2.5 */

/* since gcc-4.5 */

/* GCC: test not very accurate; enable only in relatively recent builds
 * because of bugs in gcc-4.4 (http://lists.debian.org/debian-gcc/2010/04/msg00000.html)
 */

/* XXX: equivalent of clang __builtin_unpredictable? */

/* MSVC dllexport/dllimport: appropriate __declspec depends on whether we're
 * compiling Duktape or the application.
 */

/*empty*/

/* Minimize warnings for unused internal functions with GCC >= 3.1.1 and
 * Clang.  Based on documentation it should suffice to have the attribute
 * in the declaration only, but in practice some warnings are generated unless
 * the attribute is also applied to the definition.
 */

/* --- MSVC --- */
/* http://msdn.microsoft.com/en-us/library/aa235362(VS.60).aspx */

/* XXX: DUK_UNREACHABLE for msvc? */

/* XXX: DUK_LIKELY, DUK_UNLIKELY for msvc? */
/* XXX: DUK_NOINLINE, DUK_INLINE, DUK_ALWAYS_INLINE for msvc? */

/* MSVC dllexport/dllimport: appropriate __declspec depends on whether we're
 * compiling Duktape or the application.
 */

/*empty*/

/* VS2005+ should have variadic macros even when they're not C99. */

/* VS2013+ supports union initializers but there's a bug involving union-inside-struct:
 * https://connect.microsoft.com/VisualStudio/feedback/details/805981
 * The bug was fixed (at least) in VS2015 so check for VS2015 for now:
 * https://blogs.msdn.microsoft.com/vcblog/2015/07/01/c-compiler-front-end-fixes-in-vs2015/
 * Manually tested using VS2013, CL reports 18.00.31101, so enable for VS2013 too.
 */

/* These have been tested from VS2008 onwards; may work in older VS versions
 * too but not enabled by default.
 */

/* (v)snprintf() is missing before MSVC 2015.  Note that _(v)snprintf() does
 * NOT NUL terminate on truncation, but Duktape code never assumes that.
 * http://stackoverflow.com/questions/2915672/snprintf-and-visual-studio-2010
 */

/* Avoid warning when doing DUK_UNREF(some_function). */

/* Older versions of MSVC don't support the LL/ULL suffix. */

/* --- Emscripten --- */

/* Minimize warnings for unused internal functions with GCC >= 3.1.1 and
 * Clang.  Based on documentation it should suffice to have the attribute
 * in the declaration only, but in practice some warnings are generated unless
 * the attribute is also applied to the definition.
 */

/* --- TinyC --- */

/* http://bellard.org/tcc/tcc-doc.html#SEC7 */

/* Most portable, wastes space */

/* Most portable, potentially wastes space */

/* --- VBCC --- */

/* VBCC supports C99 so check only for C99 for union initializer support.
 * Designated union initializers would possibly work even without a C99 check.
 */

/* --- Bruce's C compiler --- */

/* Most portable */

/* Most portable, wastes space */

/* Most portable, wastes space */

/* Most portable, potentially wastes space */

/* BCC, assume we're on x86. */

/* --- Generic --- */

/* C++ doesn't have standard designated union initializers ({ .foo = 1 }). */

/* Most portable, wastes space */

/* Most portable, potentially wastes space */

/* autodetect compiler */

/* uclibc */

/*
 *  Wrapper typedefs and constants for integer types, also sanity check types.
 *
 *  C99 typedefs are quite good but not always available, and we want to avoid
 *  forcibly redefining the C99 typedefs.  So, there are Duktape wrappers for
 *  all C99 typedefs and Duktape code should only use these typedefs.  Type
 *  detection when C99 is not supported is best effort and may end up detecting
 *  some types incorrectly.
 *
 *  Pointer sizes are a portability problem: pointers to different types may
 *  have a different size and function pointers are very difficult to manage
 *  portably.
 *
 *  http://en.wikipedia.org/wiki/C_data_types#Fixed-width_integer_types
 *
 *  Note: there's an interesting corner case when trying to define minimum
 *  signed integer value constants which leads to the current workaround of
 *  defining e.g. -0x80000000 as (-0x7fffffffL - 1L).  See doc/code-issues.txt
 *  for a longer discussion.
 *
 *  Note: avoid typecasts and computations in macro integer constants as they
 *  can then no longer be used in macro relational expressions (such as
 *  #if DUK_SIZE_MAX < 0xffffffffUL).  There is internal code which relies on
 *  being able to compare DUK_SIZE_MAX against a limit.
 */

/* XXX: add feature options to force basic types from outside? */

/* Check that architecture is two's complement, standard C allows e.g.
 * INT_MIN to be -2**31+1 (instead of -2**31).
 */

/* Pointer size determination based on __WORDSIZE or architecture when
 * that's not available.
 */

/* not sure, not needed with C99 anyway */

/* Intermediate define for 'have inttypes.h' */

/* vbcc + AmigaOS has C99 but no inttypes.h */

/* C++11 apparently ratified stdint.h */

/* Basic integer typedefs and limits, preferably from inttypes.h, otherwise
 * through automatic detection.
 */

/* C99 or compatible */

alias duk_uint8_t = ubyte;
alias duk_int8_t = byte;
alias duk_uint16_t = ushort;
alias duk_int16_t = short;
alias duk_uint32_t = uint;
alias duk_int32_t = int;
alias duk_uint64_t = c_ulong;
alias duk_int64_t = c_long;
alias duk_uint_least8_t = ubyte;
alias duk_int_least8_t = byte;
alias duk_uint_least16_t = ushort;
alias duk_int_least16_t = short;
alias duk_uint_least32_t = uint;
alias duk_int_least32_t = int;
alias duk_uint_least64_t = c_ulong;
alias duk_int_least64_t = c_long;
alias duk_uint_fast8_t = ubyte;
alias duk_int_fast8_t = byte;
alias duk_uint_fast16_t = c_ulong;
alias duk_int_fast16_t = c_long;
alias duk_uint_fast32_t = c_ulong;
alias duk_int_fast32_t = c_long;
alias duk_uint_fast64_t = c_ulong;
alias duk_int_fast64_t = c_long;
alias duk_uintptr_t = c_ulong;
alias duk_intptr_t = c_long;
alias duk_uintmax_t = c_ulong;
alias duk_intmax_t = c_long;

/* C99 types */

/* When C99 types are not available, we use heuristic detection to get
 * the basic 8, 16, 32, and (possibly) 64 bit types.  The fast/least
 * types are then assumed to be exactly the same for now: these could
 * be improved per platform but C99 types are very often now available.
 * 64-bit types are not available on all platforms; this is OK at least
 * on 32-bit platforms.
 *
 * This detection code is necessarily a bit hacky and can provide typedefs
 * and defines that won't work correctly on some exotic platform.
 */

/* On some platforms int is 16-bit but long is 32-bit (e.g. PureC) */

/* On some platforms int is 16-bit but long is 32-bit (e.g. PureC) */

/* 64-bit type detection is a bit tricky.
 *
 * ULLONG_MAX is a standard define.  __LONG_LONG_MAX__ and __ULONG_LONG_MAX__
 * are used by at least GCC (even if system headers don't provide ULLONG_MAX).
 * Some GCC variants may provide __LONG_LONG_MAX__ but not __ULONG_LONG_MAX__.
 *
 * ULL / LL constants are rejected / warned about by some compilers, even if
 * the compiler has a 64-bit type and the compiler/system headers provide an
 * unsupported constant (ULL/LL)!  Try to avoid using ULL / LL constants.
 * As a side effect we can only check that e.g. ULONG_MAX is larger than 32
 * bits but can't be sure it is exactly 64 bits.  Self tests will catch such
 * cases.
 */

/* cannot detect 64-bit type, not always needed so don't error */

/* Note: the funny looking computations for signed minimum 16-bit, 32-bit, and
 * 64-bit values are intentional as the obvious forms (e.g. -0x80000000L) are
 * -not- portable.  See code-issues.txt for a detailed discussion.
 */

/* 64-bit constants.  Since LL / ULL constants are not always available,
 * use computed values.  These values can't be used in preprocessor
 * comparisons; flag them as such.
 */

/* This detection is not very reliable. */

/* SIZE_MAX may be missing so use an approximate value for it. */

/* C99 types */

/* A few types are assumed to always exist. */
alias duk_size_t = c_ulong;
alias duk_ptrdiff_t = c_long;

/* The best type for an "all around int" in Duktape internals is "at least
 * 32 bit signed integer" which is most convenient.  Same for unsigned type.
 * Prefer 'int' when large enough, as it is almost always a convenient type.
 */

alias duk_int_t = int;
alias duk_uint_t = uint;

/* Same as 'duk_int_t' but guaranteed to be a 'fast' variant if this
 * distinction matters for the CPU.  These types are used mainly in the
 * executor where it might really matter.
 */
alias duk_int_fast_t = c_long;
alias duk_uint_fast_t = c_ulong;

/* Small integers (16 bits or more) can fall back to the 'int' type, but
 * have a typedef so they are marked "small" explicitly.
 */
alias duk_small_int_t = int;
alias duk_small_uint_t = uint;

/* Fast variants of small integers, again for really fast paths like the
 * executor.
 */
alias duk_small_int_fast_t = c_long;
alias duk_small_uint_fast_t = c_ulong;

/* Boolean values are represented with the platform 'unsigned int'. */
alias duk_bool_t = uint;

/* Index values must have at least 32-bit signed range. */
alias duk_idx_t = int;

/* Unsigned index variant. */
alias duk_uidx_t = uint;

/* Array index values, could be exact 32 bits.
 * Currently no need for signed duk_arridx_t.
 */
alias duk_uarridx_t = uint;

/* Duktape/C function return value, platform int is enough for now to
 * represent 0, 1, or negative error code.  Must be compatible with
 * assigning truth values (e.g. duk_ret_t rc = (foo == bar);).
 */
alias duk_ret_t = int;

/* Error codes are represented with platform int.  High bits are used
 * for flags and such, so 32 bits are needed.
 */
alias duk_errcode_t = int;

/* Codepoint type.  Must be 32 bits or more because it is used also for
 * internal codepoints.  The type is signed because negative codepoints
 * are used as internal markers (e.g. to mark EOF or missing argument).
 * (X)UTF-8/CESU-8 encode/decode take and return an unsigned variant to
 * ensure duk_uint32_t casts back and forth nicely.  Almost everything
 * else uses the signed one.
 */
alias duk_codepoint_t = int;
alias duk_ucodepoint_t = uint;

/* IEEE float/double typedef. */
alias duk_float_t = float;
alias duk_double_t = double;

/* We're generally assuming that we're working on a platform with a 32-bit
 * address space.  If DUK_SIZE_MAX is a typecast value (which is necessary
 * if SIZE_MAX is missing), the check must be avoided because the
 * preprocessor can't do a comparison.
 */

/* On some systems SIZE_MAX can be smaller than max unsigned 32-bit value
 * which seems incorrect if size_t is (at least) an unsigned 32-bit type.
 * However, it doesn't seem useful to error out compilation if this is the
 * case.
 */

/* Type used in public API declarations and user code.  Typedef maps to
 * 'struct duk_hthread' like the 'duk_hthread' typedef which is used
 * exclusively in internals.
 */
struct duk_hthread;
alias duk_context = duk_hthread;
enum DUK_USE_ARCH_STRING = "x64";
enum DUK_USE_BYTEORDER = 1;
alias DUK_VA_COPY = va_copy;

extern (D) auto DUK_LIKELY(T)(auto ref T x)
{
    return __builtin_expect(x, 1);
}

extern (D) auto DUK_UNLIKELY(T)(auto ref T x)
{
    return __builtin_expect(x, 0);
}

//alias DUK_UNPREDICTABLE = __builtin_unpredictable;
enum DUK_USE_COMPILER_STRING = "clang";
enum DUK_UINT8_MIN = 0;
enum DUK_UINT8_MAX = UINT8_MAX;
enum DUK_INT8_MIN = INT8_MIN;
enum DUK_INT8_MAX = INT8_MAX;
enum DUK_UINT_LEAST8_MIN = 0;
enum DUK_UINT_LEAST8_MAX = UINT_LEAST8_MAX;
enum DUK_INT_LEAST8_MIN = INT_LEAST8_MIN;
enum DUK_INT_LEAST8_MAX = INT_LEAST8_MAX;
enum DUK_UINT_FAST8_MIN = 0;
enum DUK_UINT_FAST8_MAX = UINT_FAST8_MAX;
enum DUK_INT_FAST8_MIN = INT_FAST8_MIN;
enum DUK_INT_FAST8_MAX = INT_FAST8_MAX;
enum DUK_UINT16_MIN = 0;
enum DUK_UINT16_MAX = UINT16_MAX;
enum DUK_INT16_MIN = INT16_MIN;
enum DUK_INT16_MAX = INT16_MAX;
enum DUK_UINT_LEAST16_MIN = 0;
enum DUK_UINT_LEAST16_MAX = UINT_LEAST16_MAX;
enum DUK_INT_LEAST16_MIN = INT_LEAST16_MIN;
enum DUK_INT_LEAST16_MAX = INT_LEAST16_MAX;
enum DUK_UINT_FAST16_MIN = 0;
enum DUK_UINT_FAST16_MAX = UINT_FAST16_MAX;
enum DUK_INT_FAST16_MIN = INT_FAST16_MIN;
enum DUK_INT_FAST16_MAX = INT_FAST16_MAX;
enum DUK_UINT32_MIN = 0;
enum DUK_UINT32_MAX = UINT32_MAX;
enum DUK_INT32_MIN = INT32_MIN;
enum DUK_INT32_MAX = INT32_MAX;
enum DUK_UINT_LEAST32_MIN = 0;
enum DUK_UINT_LEAST32_MAX = UINT_LEAST32_MAX;
enum DUK_INT_LEAST32_MIN = INT_LEAST32_MIN;
enum DUK_INT_LEAST32_MAX = INT_LEAST32_MAX;
enum DUK_UINT_FAST32_MIN = 0;
enum DUK_UINT_FAST32_MAX = UINT_FAST32_MAX;
enum DUK_INT_FAST32_MIN = INT_FAST32_MIN;
enum DUK_INT_FAST32_MAX = INT_FAST32_MAX;
enum DUK_UINT64_MIN = 0;
enum DUK_UINT64_MAX = UINT64_MAX;
enum DUK_INT64_MIN = INT64_MIN;
enum DUK_INT64_MAX = INT64_MAX;
enum DUK_UINT_LEAST64_MIN = 0;
enum DUK_UINT_LEAST64_MAX = UINT_LEAST64_MAX;
enum DUK_INT_LEAST64_MIN = INT_LEAST64_MIN;
enum DUK_INT_LEAST64_MAX = INT_LEAST64_MAX;
enum DUK_UINT_FAST64_MIN = 0;
enum DUK_UINT_FAST64_MAX = UINT_FAST64_MAX;
enum DUK_INT_FAST64_MIN = INT_FAST64_MIN;
enum DUK_INT_FAST64_MAX = INT_FAST64_MAX;
enum DUK_UINTPTR_MIN = 0;
enum DUK_UINTPTR_MAX = UINTPTR_MAX;
enum DUK_INTPTR_MIN = INTPTR_MIN;
enum DUK_INTPTR_MAX = INTPTR_MAX;
enum DUK_UINTMAX_MIN = 0;
enum DUK_UINTMAX_MAX = UINTMAX_MAX;
enum DUK_INTMAX_MIN = INTMAX_MIN;
enum DUK_INTMAX_MAX = INTMAX_MAX;
enum DUK_SIZE_MIN = 0;
enum DUK_SIZE_MAX = SIZE_MAX;
enum DUK_INT_MIN = INT_MIN;
enum DUK_INT_MAX = INT_MAX;
enum DUK_UINT_MIN = 0;
enum DUK_UINT_MAX = UINT_MAX;
enum DUK_INT_FAST_MIN = DUK_INT_FAST32_MIN;
enum DUK_INT_FAST_MAX = DUK_INT_FAST32_MAX;
enum DUK_UINT_FAST_MIN = DUK_UINT_FAST32_MIN;
enum DUK_UINT_FAST_MAX = DUK_UINT_FAST32_MAX;
enum DUK_SMALL_INT_MIN = INT_MIN;
enum DUK_SMALL_INT_MAX = INT_MAX;
enum DUK_SMALL_UINT_MIN = 0;
enum DUK_SMALL_UINT_MAX = UINT_MAX;
enum DUK_SMALL_INT_FAST_MIN = DUK_INT_FAST16_MIN;
enum DUK_SMALL_INT_FAST_MAX = DUK_INT_FAST16_MAX;
enum DUK_SMALL_UINT_FAST_MIN = DUK_UINT_FAST16_MIN;
enum DUK_SMALL_UINT_FAST_MAX = DUK_UINT_FAST16_MAX;
enum DUK_BOOL_MIN = DUK_SMALL_UINT_MIN;
enum DUK_BOOL_MAX = DUK_SMALL_UINT_MAX;
enum DUK_IDX_MIN = DUK_INT_MIN;
enum DUK_IDX_MAX = DUK_INT_MAX;
enum DUK_UIDX_MIN = DUK_UINT_MIN;
enum DUK_UIDX_MAX = DUK_UINT_MAX;
enum DUK_UARRIDX_MIN = DUK_UINT_MIN;
enum DUK_UARRIDX_MAX = DUK_UINT_MAX;
enum DUK_RET_MIN = DUK_SMALL_INT_MIN;
enum DUK_RET_MAX = DUK_SMALL_INT_MAX;
enum DUK_ERRCODE_MIN = DUK_INT_MIN;
enum DUK_ERRCODE_MAX = DUK_INT_MAX;
enum DUK_CODEPOINT_MIN = DUK_INT_MIN;
enum DUK_CODEPOINT_MAX = DUK_INT_MAX;
enum DUK_UCODEPOINT_MIN = DUK_UINT_MIN;
enum DUK_UCODEPOINT_MAX = DUK_UINT_MAX;

/* Check whether we should use 64-bit integers or not.
 *
 * Quite incomplete now.  Use 64-bit types if detected (C99 or other detection)
 * unless they are known to be unreliable.  For instance, 64-bit types are
 * available on VBCC but seem to misbehave.
 */

/*
 *  Fill-ins for platform, architecture, and compiler
 */

/* An abort()-like primitive is needed by the default fatal error handler. */

alias DUK_ABORT = abort;

version(Posix) {

alias DUK_JMPBUF_TYPE = jmp_buf;
alias DUK_SETJMP = setjmp;

}

extern (D) auto DUK_LONGJMP(T)(auto ref T jb)
{
    return longjmp(jb, 1);
}

/* sigsetjmp() alternative */

/* Special naming to avoid conflict with e.g. DUK_FREE() in duk_heap.h
 * (which is unfortunately named).  May sometimes need replacement, e.g.
 * some compilers don't handle zero length or NULL correctly in realloc().
 */

alias DUK_ANSI_MALLOC = malloc;

alias DUK_ANSI_REALLOC = realloc;

alias DUK_ANSI_CALLOC = calloc;

alias DUK_ANSI_FREE = free;

/* ANSI C (various versions) and some implementations require that the
 * pointer arguments to memset(), memcpy(), and memmove() be valid values
 * even when byte size is 0 (even a NULL pointer is considered invalid in
 * this context).  Zero-size operations as such are allowed, as long as their
 * pointer arguments point to a valid memory area.  The DUK_MEMSET(),
 * DUK_MEMCPY(), and DUK_MEMMOVE() macros require this same behavior, i.e.:
 * (1) pointers must be valid and non-NULL, (2) zero size must otherwise be
 * allowed.  If these are not fulfilled, a macro wrapper is needed.
 *
 *   http://stackoverflow.com/questions/5243012/is-it-guaranteed-to-be-safe-to-perform-memcpy0-0-0
 *   http://lists.cs.uiuc.edu/pipermail/llvmdev/2007-October/011065.html
 *
 * Not sure what's the required behavior when a pointer points just past the
 * end of a buffer, which often happens in practice (e.g. zero size memmoves).
 * For example, if allocation size is 3, the following pointer would not
 * technically point to a valid memory byte:
 *
 *   <-- alloc -->
 *   | 0 | 1 | 2 | .....
 *                 ^-- p=3, points after last valid byte (2)
 */

/* Old uclibcs have a broken memcpy so use memmove instead (this is overly wide
 * now on purpose): http://lists.uclibc.org/pipermail/uclibc-cvs/2008-October/025511.html
 */

alias DUK_MEMCPY = memcpy;

alias DUK_MEMMOVE = memmove;

alias DUK_MEMCMP = memcmp;

alias DUK_MEMSET = memset;

alias DUK_STRLEN = strlen;

alias DUK_STRCMP = strcmp;

alias DUK_STRNCMP = strncmp;

alias DUK_SPRINTF = sprintf;

/* snprintf() is technically not part of C89 but usually available. */
alias DUK_SNPRINTF = snprintf;

alias DUK_VSPRINTF = vsprintf;

/* vsnprintf() is technically not part of C89 but usually available. */
alias DUK_VSNPRINTF = vsnprintf;

alias DUK_SSCANF = sscanf;

alias DUK_VSSCANF = vsscanf;

extern (D) auto DUK_MEMZERO(T0, T1)(auto ref T0 p, auto ref T1 n)
{
    return DUK_MEMSET();
}

/* GCC older than 4.6: avoid overflow warnings related to using INFINITY */

enum DUK_DOUBLE_INFINITY = cast(double) INFINITY;

/* In VBCC (1.0 / 0.0) results in a warning and 0.0 instead of infinity.
 * Use a computed infinity (initialized when a heap is created at the
 * latest).
 */

enum DUK_DOUBLE_NAN = NAN;

/* In VBCC (0.0 / 0.0) results in a warning and 0.0 instead of NaN.
 * In MSVC (VS2010 Express) (0.0 / 0.0) results in a compile error.
 * Use a computed NaN (initialized when a heap is created at the
 * latest).
 */

/* Many platforms are missing fpclassify() and friends, so use replacements
 * if necessary.  The replacement constants (FP_NAN etc) can be anything but
 * match Linux constants now.
 */

/* Complex condition broken into separate parts. */

/* Missing some obvious constants. */

/* VBCC is missing the built-ins even in C99 mode (perhaps a header issue). */

/* AmigaOS + M68K seems to have math issues even when using GCC cross
 * compilation.  Use replacements for all AmigaOS versions on M68K
 * regardless of compiler.
 */

/* Placeholder fix for (detection is wider than necessary):
 * http://llvm.org/bugs/show_bug.cgi?id=17788
 */

/* At least some uclibc versions have broken floating point math.  For
 * example, fpclassify() can incorrectly classify certain NaN formats.
 * To be safe, use replacements.
 */

/* Older versions may be missing isnan(), etc. */

/* These functions don't currently need replacement but are wrapped for
 * completeness.  Because these are used as function pointers, they need
 * to be defined as concrete C functions (not macros).
 */

alias DUK_FABS = fabs;

alias DUK_FLOOR = floor;

alias DUK_CEIL = ceil;

alias DUK_FMOD = fmod;

alias DUK_POW = pow;

alias DUK_ACOS = acos;

alias DUK_ASIN = asin;

alias DUK_ATAN = atan;

alias DUK_ATAN2 = atan2;

alias DUK_SIN = sin;

alias DUK_COS = cos;

alias DUK_TAN = tan;

alias DUK_EXP = exp;

alias DUK_LOG = log;

alias DUK_SQRT = sqrt;

/* The functions below exist only in C99/C++11 or later and need a workaround
 * for platforms that don't include them.  MSVC isn't detected as C99, but
 * these functions also exist in MSVC 2013 and later so include a clause for
 * that too.  Android doesn't have log2; disable all of these for Android.
 */


/* DUK_F_C99 etc */

/* NetBSD 6.0 x86 (at least) has a few problems with pow() semantics,
 * see test-bug-netbsd-math-pow.js.  MinGW has similar (but different)
 * issues, see test-bug-mingw-math-issues.js.  Enable pow() workarounds
 * for these targets.
 */

/* Similar workarounds for atan2() semantics issues.  MinGW issues are
 * documented in test-bug-mingw-math-issues.js.
 */

/* Rely as little as possible on compiler behavior for NaN comparison,
 * signed zero handling, etc.  Currently never activated but may be needed
 * for broken compilers.
 */

/* There was a curious bug where test-bi-date-canceling.js would fail e.g.
 * on 64-bit Ubuntu, gcc-4.8.1, -m32, and no -std=c99.  Some date computations
 * using doubles would be optimized which then broke some corner case tests.
 * The problem goes away by adding 'volatile' to the datetime computations.
 * Not sure what the actual triggering conditions are, but using this on
 * non-C99 systems solves the known issues and has relatively little cost
 * on other platforms.
 */

/*
 *  Byte order and double memory layout detection
 *
 *  Endianness detection is a major portability hassle because the macros
 *  and headers are not standardized.  There's even variance across UNIX
 *  platforms.  Even with "standard" headers, details like underscore count
 *  varies between platforms, e.g. both __BYTE_ORDER and _BYTE_ORDER are used
 *  (Crossbridge has a single underscore, for instance).
 *
 *  The checks below are structured with this in mind: several approaches are
 *  used, and at the end we check if any of them worked.  This allows generic
 *  approaches to be tried first, and platform/compiler specific hacks tried
 *  last.  As a last resort, the user can force a specific endianness, as it's
 *  not likely that automatic detection will work on the most exotic platforms.
 *
 *  Duktape supports little and big endian machines.  There's also support
 *  for a hybrid used by some ARM machines where integers are little endian
 *  but IEEE double values use a mixed order (12345678 -> 43218765).  This
 *  byte order for doubles is referred to as "mixed endian".
 */

/* GCC and Clang provide endianness defines as built-in predefines, with
 * leading and trailing double underscores (e.g. __BYTE_ORDER__).  See
 * output of "make gccpredefs" and "make clangpredefs".  Clang doesn't
 * seem to provide __FLOAT_WORD_ORDER__; assume not mixed endian for clang.
 * http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
 */

/* Float word order not known, assume not a hybrid. */

/* Byte order is little endian but cannot determine IEEE double word order. */
/* float word order */

/* Float word order not known, assume not a hybrid. */

/* Byte order is big endian but cannot determine IEEE double word order. */
/* float word order */

/* Cannot determine byte order; __ORDER_PDP_ENDIAN__ is related to 32-bit
 * integer ordering and is not relevant.
 */
/* integer byte order */
/* !defined(DUK_USE_BYTEORDER) && defined(__BYTE_ORDER__) */

/* More or less standard endianness predefines provided by header files.
 * The ARM hybrid case is detected by assuming that __FLOAT_WORD_ORDER
 * will be big endian, see: http://lists.mysql.com/internals/443.
 * On some platforms some defines may be present with an empty value which
 * causes comparisons to fail: https://github.com/svaarala/duktape/issues/453.
 */

/* Float word order not known, assume not a hybrid. */

/* Byte order is little endian but cannot determine IEEE double word order. */
/* float word order */

/* Float word order not known, assume not a hybrid. */

/* Byte order is big endian but cannot determine IEEE double word order. */
/* float word order */

/* Cannot determine byte order. */
/* integer byte order */
/* !defined(DUK_USE_BYTEORDER) */

/* QNX gcc cross compiler seems to define e.g. __LITTLEENDIAN__ or __BIGENDIAN__:
 *  $ /opt/qnx650/host/linux/x86/usr/bin/i486-pc-nto-qnx6.5.0-gcc -dM -E - </dev/null | grep -ni endian
 *  67:#define __LITTLEENDIAN__ 1
 *  $ /opt/qnx650/host/linux/x86/usr/bin/mips-unknown-nto-qnx6.5.0-gcc -dM -E - </dev/null | grep -ni endian
 *  81:#define __BIGENDIAN__ 1
 *  $ /opt/qnx650/host/linux/x86/usr/bin/arm-unknown-nto-qnx6.5.0-gcc -dM -E - </dev/null | grep -ni endian
 *  70:#define __LITTLEENDIAN__ 1
 */

/*
 *  Alignment requirement and support for unaligned accesses
 *
 *  Assume unaligned accesses are not supported unless specifically allowed
 *  in the target platform.  Some platforms may support unaligned accesses
 *  but alignment to 4 or 8 may still be desirable.  Note that unaligned
 *  accesses (and even pointers) relative to natural alignment (regardless
 *  of target alignment) are technically undefined behavior and thus
 *  compiler/architecture specific.
 */

/* If not forced, use safe default for alignment. */

enum DUK_USE_ALIGN_BY = 8;

/* Compiler specific hackery needed to force struct size to match aligment,
 * see e.g. duk_hbuffer.h.
 *
 * http://stackoverflow.com/questions/11130109/c-struct-size-alignment
 * http://stackoverflow.com/questions/10951039/specifying-64-bit-alignment
 */

/* We need va_copy() which is defined in C99 / C++11, so an awkward
 * replacement is needed for pre-C99 / pre-C++11 environments.  This
 * will quite likely need portability hacks for some non-C99
 * environments.
 */

/* C99 / C++11 and above: rely on va_copy() which is required.
 * Omit parenthesis on macro right side on purpose to minimize differences
 * to direct use.
 */

/* Pre-C99: va_list type is implementation dependent.  This replacement
 * assumes it is a plain value so that a simple assignment will work.
 * This is not the case on all platforms (it may be a single-array element,
 * for instance).
 */

/* Macro hackery to convert e.g. __LINE__ to a string without formatting,
 * see: http://stackoverflow.com/questions/240353/convert-a-preprocessor-token-to-a-string
 */
extern (D) string DUK_MACRO_STRINGIFY_HELPER(T)(auto ref T x)
{
    import std.conv : to;

    return to!string(x);
}

alias DUK_MACRO_STRINGIFY = DUK_MACRO_STRINGIFY_HELPER;

/* This can be used for testing; valgrind will then indicate the C call stack
 * leading to the call site.
 */

/* Macro for suppressing warnings for potentially unreferenced variables.
 * The variables can be actually unreferenced or unreferenced in some
 * specific cases only; for instance, if a variable is only debug printed,
 * it is unreferenced when debug printing is disabled.  May cause warnings
 * for volatile arguments.
 */

/* Fillin for DUK_NORETURN; DUK_WO_NORETURN() is used to insert dummy
 * dummy statements after noreturn calls to silence harmless compiler
 * warnings, e.g.:
 *
 *   DUK_ERROR_TYPE(thr, "aiee");
 *   DUK_WO_NORETURN(return 0;);
 *
 * Statements inside DUK_WO_NORETURN() must NEVER be actually reachable,
 * and they're only included to satisfy the compiler.
 */

/* Don't know how to declare unreachable point, so don't do it; this
 * may cause some spurious compilation warnings (e.g. "variable used
 * uninitialized").
 */

/* Convert any input pointer into a "void *", losing a const qualifier.
 * This is not fully portable because casting through duk_uintptr_t may
 * not work on all architectures (e.g. those with long, segmented pointers).
 */
extern (D) auto DUK_LOSE_CONST(T)(auto ref T src)
{
    return cast(void*) cast(duk_uintptr_t) src;
}

/*nop*/

/*nop*/

/*nop*/ /*nop*/ /*nop*/

/*empty*/

/*empty*/

enum DUK_FILE_MACRO = __FILE__;

enum DUK_LINE_MACRO = __LINE__;

extern (D) auto DUK_BSWAP32(T)(auto ref T x)
{
    return ((cast(duk_uint32_t) x) >> 24) | (((cast(duk_uint32_t) x) >> 8) & 0xff00UL) | (((cast(duk_uint32_t) x) << 8) & 0xff0000UL) | ((cast(duk_uint32_t) x) << 24);
}

extern (D) auto DUK_BSWAP16(T)(auto ref T x)
{
    return (cast(duk_uint16_t) x >> 8) | (cast(duk_uint16_t) x << 8);
}

/* DUK_USE_VARIADIC_MACROS: required from compilers, so no fill-in. */
/* DUK_USE_UNION_INITIALIZERS: required from compilers, so no fill-in. */

/* Not standard but common enough */

/* not defined by default */

extern (D) string DUK_U64_CONSTANT(T)(auto ref T x)
{
    import std.conv : to;

    return to!string(x) ~ "ULL";
}

extern (D) string DUK_I64_CONSTANT(T)(auto ref T x)
{
    import std.conv : to;

    return to!string(x) ~ "LL";
}

/* Workaround for GH-323: avoid inlining control when compiling from
 * multiple sources, as it causes compiler portability trouble.
 */ /*nop*/ /*nop*/ /*nop*/

/*
 *  Check whether or not a packed duk_tval representation is possible.
 *  What's basically required is that pointers are 32-bit values
 *  (sizeof(void *) == 4).  Best effort check, not always accurate.
 *  If guess goes wrong, crashes may result; self tests also verify
 *  the guess.
 */

/* Explicit marker needed; may be 'defined', 'undefined, 'or 'not provided'. */

/* Strict C99 case: DUK_UINTPTR_MAX (= UINTPTR_MAX) should be very reliable */

/* Non-C99 case, still relying on DUK_UINTPTR_MAX, as long as it is not a computed value */

/* DUK_SIZE_MAX (= SIZE_MAX) is often reliable */

/* DUK_F_PACKED_TVAL_PROVIDED */
/* Object property allocation layout has implications for memory and code
 * footprint and generated code size/speed.  The best layout also depends
 * on whether the platform has alignment requirements or benefits from
 * having mostly aligned accesses.
 */

/* On platforms without any alignment issues, layout 1 is preferable
 * because it compiles to slightly less code and provides direct access
 * to property keys.
 */

/* On other platforms use layout 2, which requires some padding but
 * is a bit more natural than layout 3 in ordering the entries.  Layout
 * 3 is currently not used.
 */

/* GCC/clang inaccurate math would break compliance and probably duk_tval,
 * so refuse to compile.  Relax this if -ffast-math is tested to work.
 */

/*
 *  Autogenerated defaults
 */

enum DUK_USE_CALLSTACK_LIMIT = 10000;
enum DUK_USE_COMPILER_RECLIMIT = 2500;

enum DUK_USE_DEBUG_BUFSIZE = 65536L;
enum DUK_USE_DEBUG_LEVEL = 0;

enum DUK_USE_ESBC_MAX_BYTES = 2147418112L;
enum DUK_USE_ESBC_MAX_LINENUMBER = 2147418112L;

enum DUK_USE_FATAL_MAXLEN = 128;

enum DUK_USE_HOBJECT_ARRAY_ABANDON_LIMIT = 2;
enum DUK_USE_HOBJECT_ARRAY_FAST_RESIZE_LIMIT = 9;
enum DUK_USE_HOBJECT_ARRAY_MINGROW_ADD = 16;
enum DUK_USE_HOBJECT_ARRAY_MINGROW_DIVISOR = 8;
enum DUK_USE_HOBJECT_ENTRY_MINGROW_ADD = 16;
enum DUK_USE_HOBJECT_ENTRY_MINGROW_DIVISOR = 8;
enum DUK_USE_HOBJECT_HASH_PROP_LIMIT = 8;

enum DUK_USE_JSON_DEC_RECLIMIT = 1000;
enum DUK_USE_JSON_ENC_RECLIMIT = 1000;

enum DUK_USE_LITCACHE_SIZE = 256;
enum DUK_USE_MARK_AND_SWEEP_RECLIMIT = 256;
enum DUK_USE_NATIVE_CALL_RECLIMIT = 1000;

enum DUK_USE_REGEXP_COMPILER_RECLIMIT = 10000;
enum DUK_USE_REGEXP_EXECUTOR_RECLIMIT = 10000;

enum DUK_USE_ROM_PTRCOMP_FIRST = 63488L;

enum DUK_USE_STRHASH_SKIP_SHIFT = 5;

enum DUK_USE_STRTAB_GROW_LIMIT = 17;
enum DUK_USE_STRTAB_MAXSIZE = 268435456L;
enum DUK_USE_STRTAB_MINSIZE = 1024;

enum DUK_USE_STRTAB_RESIZE_CHECK_MASK = 255;
enum DUK_USE_STRTAB_SHRINK_LIMIT = 6;

enum DUK_USE_TARGET_INFO = "unknown";
enum DUK_USE_TRACEBACK_DEPTH = 10; /* no user declarations */
enum DUK_USE_VALSTACK_GROW_SHIFT = 2;
enum DUK_USE_VALSTACK_LIMIT = 1000000L;
enum DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT = 2;
enum DUK_USE_VALSTACK_SHRINK_SLACK_SHIFT = 4;

/*
 *  You may add overriding #define/#undef directives below for
 *  customization.  You of course cannot un-#include or un-typedef
 *  anything; these require direct changes above.
 */

/* __OVERRIDE_DEFINES__ */

/*
 *  Conditional includes
 */

/* std::exception */
/* std::runtime_error */

/*
 *  Date provider selection
 *
 *  User may define DUK_USE_DATE_GET_NOW() etc directly, in which case we'll
 *  rely on an external provider.  If this is not done, revert to previous
 *  behavior and use Unix/Windows built-in provider.
 */

/* External provider already defined. */

/* External provider already defined. */

/* External provider already defined. */

/* No provider for DUK_USE_DATE_PARSE_STRING(), fall back to ISO 8601 only. */

/* External provider already defined. */

/* No provider for DUK_USE_DATE_FORMAT_STRING(), fall back to ISO 8601 only. */

/* External provider already defined. */

/* No provider for DUK_USE_GET_MONOTONIC_TIME(), fall back to DUK_USE_DATE_GET_NOW(). */

/* DUK_COMPILING_DUKTAPE */

/*
 *  Checks for legacy feature options (DUK_OPT_xxx)
 */

/*
 *  Checks for config option consistency (DUK_USE_xxx)
 */

/*
 *  Convert DUK_USE_BYTEORDER, from whatever source, into currently used
 *  internal defines.  If detection failed, #error out.
 */

/* integer endianness is little on purpose */

/* byte order */

/* defined(DUK_USE_BYTEORDER) */

/* DUK_CONFIG_H_INCLUDED */
